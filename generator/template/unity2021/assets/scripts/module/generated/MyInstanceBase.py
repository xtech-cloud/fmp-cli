import os
import uuid
from generator.template.utility import writer

template = """
//*************************************************************************************
//   !!! Generated by the fmp-cli {{version}}.  DO NOT EDIT!
//*************************************************************************************

using System.Threading.Tasks;
using System.Collections.Generic;
using UnityEngine;
using LibMVCS = XTC.FMP.LIB.MVCS;
using {{org_name}}.FMP.MOD.{{module_name}}.LIB.Bridge;
using {{org_name}}.FMP.MOD.{{module_name}}.LIB.MVCS;
using {{org_name}}.FMP.MOD.{{module_name}}.LIB.Proto;

namespace {{org_name}}.FMP.MOD.{{module_name}}.LIB.Unity
{
    public class MyInstanceBase
    {
        public LibMVCS.Logger logger { get; set; }
        public MyConfig config { get; set; }
        public Dictionary<string, LibMVCS.Any> settings { get; set; }
        public GameObject rootUI { get; set; }

{{member_blocks}}

        protected void loadSpriteFromTheme(string _file, System.Action<Sprite> _onFinish)
        {
            Sprite sprite = null;

            string datapath = settings["datapath"].AsString();
            string vendor = settings["vendor"].AsString();
            string dir = System.IO.Path.Combine(datapath, vendor);
            dir = System.IO.Path.Combine(dir, "theme");
            dir = System.IO.Path.Combine(dir, MyEntryBase.ModuleName);
            string filefullpath = System.IO.Path.Combine(dir, _file);
            if (System.IO.File.Exists(filefullpath))
            {
                var bytes = System.IO.File.ReadAllBytes(filefullpath);
                var texture = new Texture2D(10, 10, TextureFormat.RGBA32, false);
                texture.LoadImage(bytes);
                sprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f));
            }

            _onFinish(sprite);
        }

{{method_blocks}}

    }
}
"""

template_members = """
        public I{{service}}ViewBridge viewBridge{{service}} { get; set; }
"""

template_method = """
        protected virtual void submit{{service}}{{rpc}}({{request}} _request)
        {
            var dto = new {{request}}DTO(_request);
            Task.Run(async () =>
            {
                try
                {
                    var reslut = await viewBridge{{service}}.On{{rpc}}Submit(dto);
                    if (!LibMVCS.Error.IsOK(reslut))
                    {
                        logger.Error(reslut.getMessage());
                    }
                }
                catch (System.Exception ex)
                {
                    logger.Exception(ex);
                }
            });
        }
"""

def generate(_options, _outputdir: str):
    output_dir = os.path.join(_outputdir, "Assets")
    os.makedirs(output_dir, exist_ok=True)
    output_dir = os.path.join(output_dir, "Scripts")
    os.makedirs(output_dir, exist_ok=True)
    output_dir = os.path.join(output_dir, "Module")
    os.makedirs(output_dir, exist_ok=True)
    output_dir = os.path.join(output_dir, "_Generated_")
    os.makedirs(output_dir, exist_ok=True)

    member_blocks = ""
    method_blocks = ""
    services = _options["services"]
    for service in services.keys():
        member_blocks = member_blocks + template_members.replace("{{service}}", service)
        for rpc_name in services[service].keys():
            rpc_map = services[service][rpc_name]
            method_block = template_method
            method_block = method_block.replace("{{service}}", service)
            method_block = method_block.replace("{{rpc}}", rpc_name)
            method_block = method_block.replace("{{request}}", rpc_map[0])
            method_blocks = method_blocks + method_block

    contents = template
    contents = contents.replace("{{org_name}}", _options["org_name"])
    contents = contents.replace("{{module_name}}", _options["module_name"])
    contents = contents.replace("{{version}}", _options["version"])
    contents = contents.replace("{{member_blocks}}", member_blocks)
    contents = contents.replace("{{method_blocks}}", method_blocks)
    output_path = os.path.join(output_dir, "MyInstanceBase.cs")
    writer.write(output_path, contents, True)
